# FreeRTOS Queues

## FreeRTOS队列

队列是任务间通信的主要方式。队列可用于在任务之间以及中断和任务之间发送消息。大多数情况下，队列用作线程安全的 FIFO（先进先出）缓冲区，将新数据发送到队列的后面，数据也可以发送到队列的前面。

![FreeRTOS队列](https://freertos.org/fr-content-src/uploads/2018/07/queue_animation.gif "队列的读写")

## 用户模型: 最大灵活性和简单性

FreeRTOS队列使用将简单性与灵活性相结合的模型设计方法——二者通常是互斥的。 通过复制将消息通过队列发送出去，这意味着数据(可能是指向更大缓冲区的指针)本身被复制到队列中，而不是队列总是只存储对数据的引用。该方案的优势在于: 

*   已经包含在C变量中占用少量空间的消息(整数、小型结构体等)可直接发送到队列中。系统无需为这些消息分配缓冲区或者将变量复制到所分配的缓冲区中。同样，消息可以直接从队列中读取到C变量中。

    此外，即便发送的消息仍保留在队列中，通过这种方法发送到队列可以使发送任务立即覆盖原来的变量或buffer。因为变量中包含的数据已经被复制到队列中，所以变量本身可重复使用。未对发送和接收消息的任务同意哪个任务拥有该消息进行要求，也不要求在不再需要消息时哪个任务负责释放该消息。 

*   采用通过复制传递数据的队列不会阻止队列通过引用的方式传递数据。 当消息的大小达到无法将整个消息逐字节复制到队列中时，请定义储存指针的队列，只需要将指向消息的指针复制到队列中。 这正是FreeRTOS+UDP实现围绕FreeRTOS IP堆栈传递大型网络buffer的方式。 

*   RTOS内核负责分配用作队列存储区的内存。

*   通过定义队列发送可变大小的消息，从而保存所需要的结构体。该结构体包含指向队列消息的成员和保存队列消息大小的另一个成员。

*   单个队列可用于接收不同类型的消息和来自多个位置的消息，方法是定义保存一个结构体的队列。结构体的一个成员保存消息类型，另一个成员保存消息数据(或指向消息数据的指针)。 解析数据的具体方式取决于消息类型。 这正是管理FreeRTOS+UDP IP堆栈的任务能够使用单个队列接收ARP计时器事件通知、从以太网硬件接收的数据包、从应用程序接收的数据包、网络故障事件等的方法。

*   该方案适用于受内存保护的场景。 受限于内存保护的任务可以通过调用RTOS发送队列会提高微控制器优先级，将数据传递给同样受限于内存保护(但所保护的内存区域不同)的任务。队列存储区只能由RTOS访问(RTOS具有完全权限)。

*   一个单独的API被用来在中断内部使用。 将RTOS任务中使用的API与中断服务例程中使用的API分开意味着RTOS API函数的实现不会带来每次执行时检查其调用上下文的开销。使用单独的中断API还意味着: 在大多数情况下，与RTOS竞争产品相比，用户创建的RTOS中断服务例程更简便。

*   在各个方面，API都更为简单。 

## 队列的阻塞

队列的API函数允许指定阻塞时间。

当一个任务尝试从一个空队列中读取数据时，该任务将被置于阻塞状态(因此不占用任何CPU时间并且其他任务可以运行)，直到队列中的数据变得可用或者到达指定的阻塞时间。

当一个任务尝试写入一个已满的队列时，该任务同样将被置于阻塞状态(因此不消耗任何CPU时间并且其他任务可以运行)，直到队列中有可用空间或到达指定的阻塞时间。 

如果同一队列中有多个任务阻塞，则第一个被解除阻塞的任务将是优先级最高的任务。 
